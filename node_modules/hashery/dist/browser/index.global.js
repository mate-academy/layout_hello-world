"use strict";(()=>{var x=Object.defineProperty;var A=(t,e,r)=>e in t?x(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var h=(t,e,r)=>A(t,typeof e!="symbol"?e+"":e,r);var L=class{constructor(t){h(this,"_eventListeners");h(this,"_maxListeners");h(this,"_logger");h(this,"_throwOnEmitError",!1);h(this,"_throwOnEmptyListeners",!1);h(this,"_errorEvent","error");this._eventListeners=new Map,this._maxListeners=100,this._logger=t?.logger,t?.throwOnEmitError!==void 0&&(this._throwOnEmitError=t.throwOnEmitError),t?.throwOnEmptyListeners!==void 0&&(this._throwOnEmptyListeners=t.throwOnEmptyListeners)}get logger(){return this._logger}set logger(t){this._logger=t}get throwOnEmitError(){return this._throwOnEmitError}set throwOnEmitError(t){this._throwOnEmitError=t}get throwOnEmptyListeners(){return this._throwOnEmptyListeners}set throwOnEmptyListeners(t){this._throwOnEmptyListeners=t}once(t,e){let r=(...s)=>{this.off(t,r),e(...s)};return this.on(t,r),this}listenerCount(t){if(t===void 0)return this.getAllListeners().length;let e=this._eventListeners.get(t);return e?e.length:0}eventNames(){return[...this._eventListeners.keys()]}rawListeners(t){return t===void 0?this.getAllListeners():this._eventListeners.get(t)??[]}prependListener(t,e){let r=this._eventListeners.get(t)??[];return r.unshift(e),this._eventListeners.set(t,r),this}prependOnceListener(t,e){let r=(...s)=>{this.off(t,r),e(...s)};return this.prependListener(t,r),this}maxListeners(){return this._maxListeners}addListener(t,e){return this.on(t,e),this}on(t,e){this._eventListeners.has(t)||this._eventListeners.set(t,[]);let r=this._eventListeners.get(t);return r&&(r.length>=this._maxListeners&&console.warn(`MaxListenersExceededWarning: Possible event memory leak detected. ${r.length+1} ${t} listeners added. Use setMaxListeners() to increase limit.`),r.push(e)),this}removeListener(t,e){return this.off(t,e),this}off(t,e){let r=this._eventListeners.get(t)??[],s=r.indexOf(e);return s!==-1&&r.splice(s,1),r.length===0&&this._eventListeners.delete(t),this}emit(t,...e){let r=!1,s=this._eventListeners.get(t);if(s&&s.length>0)for(let i of s)i(...e),r=!0;if(t===this._errorEvent){let i=e[0]instanceof Error?e[0]:new Error(`${e[0]}`);if(this._throwOnEmitError&&!r)throw i;if(this.listeners(this._errorEvent).length===0&&this._throwOnEmptyListeners===!0)throw i}return this.sendLog(t,e),r}listeners(t){return this._eventListeners.get(t)??[]}removeAllListeners(t){return t!==void 0?this._eventListeners.delete(t):this._eventListeners.clear(),this}setMaxListeners(t){this._maxListeners=t;for(let e of this._eventListeners.values())e.length>t&&e.splice(t)}getAllListeners(){let t=[];for(let e of this._eventListeners.values())t=[...t,...e];return t}sendLog(t,e){if(!this._logger)return;let r;switch(typeof e=="string"?r=e:Array.isArray(e)&&e.length>0&&e[0]instanceof Error?r=e[0].message:e instanceof Error?r=e.message:Array.isArray(e)&&e.length>0&&typeof e[0]?.message=="string"?r=e[0].message:r=JSON.stringify(e),t){case"error":{this._logger.error?.(r,{event:t,data:e});break}case"warn":{this._logger.warn?.(r,{event:t,data:e});break}case"trace":{this._logger.trace?.(r,{event:t,data:e});break}case"debug":{this._logger.debug?.(r,{event:t,data:e});break}case"fatal":{this._logger.fatal?.(r,{event:t,data:e});break}default:{this._logger.info?.(r,{event:t,data:e});break}}}},v=class extends L{constructor(e){super({logger:e?.logger,throwOnEmitError:e?.throwOnEmitError,throwOnEmptyListeners:e?.throwOnEmptyListeners});h(this,"_hooks");h(this,"_throwOnHookError",!1);h(this,"_enforceBeforeAfter",!1);h(this,"_deprecatedHooks");h(this,"_allowDeprecated",!0);this._hooks=new Map,this._deprecatedHooks=e?.deprecatedHooks?new Map(e.deprecatedHooks):new Map,e?.throwOnHookError!==void 0?this._throwOnHookError=e.throwOnHookError:e?.throwHookErrors!==void 0&&(this._throwOnHookError=e.throwHookErrors),e?.enforceBeforeAfter!==void 0&&(this._enforceBeforeAfter=e.enforceBeforeAfter),e?.allowDeprecated!==void 0&&(this._allowDeprecated=e.allowDeprecated)}get hooks(){return this._hooks}get throwHookErrors(){return this._throwOnHookError}set throwHookErrors(e){this._throwOnHookError=e}get throwOnHookError(){return this._throwOnHookError}set throwOnHookError(e){this._throwOnHookError=e}get enforceBeforeAfter(){return this._enforceBeforeAfter}set enforceBeforeAfter(e){this._enforceBeforeAfter=e}get deprecatedHooks(){return this._deprecatedHooks}set deprecatedHooks(e){this._deprecatedHooks=e}get allowDeprecated(){return this._allowDeprecated}set allowDeprecated(e){this._allowDeprecated=e}validateHookName(e){if(this._enforceBeforeAfter){let r=e.trim().toLocaleLowerCase();if(!r.startsWith("before")&&!r.startsWith("after"))throw new Error(`Hook event "${e}" must start with "before" or "after" when enforceBeforeAfter is enabled`)}}checkDeprecatedHook(e){if(this._deprecatedHooks.has(e)){let r=this._deprecatedHooks.get(e),s=`Hook "${e}" is deprecated${r?`: ${r}`:""}`;return this.emit("warn",{hook:e,message:s}),this._allowDeprecated}return!0}onHook(e,r){if(this.validateHookName(e),!this.checkDeprecatedHook(e))return;let s=this._hooks.get(e);s?s.push(r):this._hooks.set(e,[r])}onHookEntry(e){this.onHook(e.event,e.handler)}addHook(e,r){this.onHook(e,r)}onHooks(e){for(let r of e)this.onHook(r.event,r.handler)}prependHook(e,r){if(this.validateHookName(e),!this.checkDeprecatedHook(e))return;let s=this._hooks.get(e);s?s.unshift(r):this._hooks.set(e,[r])}prependOnceHook(e,r){if(this.validateHookName(e),!this.checkDeprecatedHook(e))return;let s=async(...i)=>(this.removeHook(e,s),r(...i));this.prependHook(e,s)}onceHook(e,r){if(this.validateHookName(e),!this.checkDeprecatedHook(e))return;let s=async(...i)=>(this.removeHook(e,s),r(...i));this.onHook(e,s)}removeHook(e,r){if(this.validateHookName(e),!this.checkDeprecatedHook(e))return;let s=this._hooks.get(e);if(s){let i=s.indexOf(r);i!==-1&&s.splice(i,1)}}removeHooks(e){for(let r of e)this.removeHook(r.event,r.handler)}async hook(e,...r){if(this.validateHookName(e),!this.checkDeprecatedHook(e))return;let s=this._hooks.get(e);if(s)for(let i of s)try{await i(...r)}catch(o){let a=`${e}: ${o.message}`;if(this.emit("error",new Error(a)),this._throwOnHookError)throw new Error(a)}}async beforeHook(e,...r){await this.hook(`before:${e}`,...r)}async afterHook(e,...r){await this.hook(`after:${e}`,...r)}async callHook(e,...r){await this.hook(e,...r)}getHooks(e){if(this.validateHookName(e),!!this.checkDeprecatedHook(e))return this._hooks.get(e)}clearHooks(){this._hooks.clear()}};var p=class{constructor(e){h(this,"_enabled",!0);h(this,"_maxSize",4e3);h(this,"_store",new Map);h(this,"_keys",[]);e?.enabled!==void 0&&(this._enabled=e.enabled),e?.maxSize!==void 0&&(this._maxSize=e.maxSize)}get enabled(){return this._enabled}set enabled(e){this._enabled=e}get maxSize(){return this._maxSize}set maxSize(e){this._maxSize=e}get store(){return this._store}get size(){return this._store.size}get(e){return this._store.get(e)}set(e,r){if(this._enabled){if(this._store.has(e)){this._store.set(e,r);return}if(this._store.size>=this._maxSize){let s=this._keys.shift();s&&this._store.delete(s)}this._keys.push(e),this._store.set(e,r)}}has(e){return this._store.has(e)}clear(){this._store.clear(),this._keys=[]}};var y=class{get name(){return"crc32"}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let a=e;r=new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}let s=3988292384,i=4294967295;for(let a=0;a<r.length;a++){i=i^r[a];for(let n=0;n<8;n++)i=i>>>1^s&-(i&1)}return i=(i^4294967295)>>>0,i.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var m=class{constructor(e){h(this,"_algorithm","SHA-256");e?.algorithm&&(this._algorithm=e?.algorithm)}get name(){return this._algorithm}async toHash(e){let r=await crypto.subtle.digest(this._algorithm,e);return Array.from(new Uint8Array(r)).map(o=>o.toString(16).padStart(2,"0")).join("")}};var _=class{get name(){return"djb2"}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let o=e;r=new Uint8Array(o.buffer,o.byteOffset,o.byteLength)}let s=5381;for(let o=0;o<r.length;o++)s=(s<<5)+s+r[o],s=s>>>0;return s.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var H=class{get name(){return"fnv1"}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let n=e;r=new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}let s=2166136261,i=16777619,o=s;for(let n=0;n<r.length;n++)o=o*i,o=o^r[n],o=o>>>0;return o.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var b=class{constructor(e=0){h(this,"_seed");this._seed=e>>>0}get name(){return"murmer"}get seed(){return this._seed}toHashSync(e){let r;if(e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else if(e instanceof DataView)r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let l=e;r=new Uint8Array(l.buffer,l.byteOffset,l.byteLength)}let s=3432918353,i=461845907,o=r.length,a=Math.floor(o/4),n=this._seed;for(let l=0;l<a;l++){let u=l*4,g=r[u]&255|(r[u+1]&255)<<8|(r[u+2]&255)<<16|(r[u+3]&255)<<24;g=this._imul(g,s),g=this._rotl32(g,15),g=this._imul(g,i),n^=g,n=this._rotl32(n,13),n=this._imul(n,5)+3864292196}let d=a*4,c=0;switch(o&3){case 3:c^=(r[d+2]&255)<<16;case 2:c^=(r[d+1]&255)<<8;case 1:c^=r[d]&255,c=this._imul(c,s),c=this._rotl32(c,15),c=this._imul(c,i),n^=c}return n^=o,n^=n>>>16,n=this._imul(n,2246822507),n^=n>>>13,n=this._imul(n,3266489909),n^=n>>>16,n=n>>>0,n.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}_imul(e,r){if(Math.imul)return Math.imul(e,r);let s=e>>>16&65535;let i=e&65535;let o=r>>>16&65535;let a=r&65535;return i*a+(s*a+i*o<<16>>>0)|0}_rotl32(e,r){return e<<r|e>>>32-r}};var w=class{constructor(e){h(this,"_providers",new Map);h(this,"_getFuzzy",!0);e?.providers&&this.loadProviders(e?.providers),e?.getFuzzy!==void 0&&(this._getFuzzy=!!e?.getFuzzy)}loadProviders(e){for(let r of e)this._providers.set(r.name,r)}get providers(){return this._providers}set providers(e){this._providers=e}get names(){return Array.from(this._providers.keys())}get(e,r){let s=r?.fuzzy??this._getFuzzy;e=e.trim();let i=this._providers.get(e);return i===void 0&&s===!0&&(e=e.toLowerCase(),i=this._providers.get(e)),i===void 0&&s===!0&&(e=e.replaceAll("-",""),i=this._providers.get(e)),i}add(e){this._providers.set(e.name,e)}remove(e){return this._providers.delete(e)}};var k=class extends v{constructor(r){super(r);h(this,"_parse",JSON.parse);h(this,"_stringify",JSON.stringify);h(this,"_providers",new w);h(this,"_defaultAlgorithm","SHA-256");h(this,"_defaultAlgorithmSync","djb2");h(this,"_cache");r?.parse&&(this._parse=r.parse),r?.stringify&&(this._stringify=r.stringify),r?.defaultAlgorithm&&(this._defaultAlgorithm=r.defaultAlgorithm),r?.defaultAlgorithmSync&&(this._defaultAlgorithmSync=r.defaultAlgorithmSync),this._cache=new p(r?.cache),this.loadProviders(r?.providers,{includeBase:r?.includeBase??!0})}get parse(){return this._parse}set parse(r){this._parse=r}get stringify(){return this._stringify}set stringify(r){this._stringify=r}get providers(){return this._providers}set providers(r){this._providers=r}get names(){return this._providers.names}get defaultAlgorithm(){return this._defaultAlgorithm}set defaultAlgorithm(r){this._defaultAlgorithm=r}get defaultAlgorithmSync(){return this._defaultAlgorithmSync}set defaultAlgorithmSync(r){this._defaultAlgorithmSync=r}get cache(){return this._cache}async toHash(r,s){let i={data:r,algorithm:s?.algorithm??this._defaultAlgorithm,maxLength:s?.maxLength};await this.beforeHook("toHash",i);let o=this._stringify(i.data),a=`${i.algorithm}:${o}`;if(this._cache.enabled){let u=this._cache.get(a);if(u!==void 0)return s?.maxLength&&u.length>s.maxLength?u.substring(0,s.maxLength):u}let d=new TextEncoder().encode(o),c=this._providers.get(i.algorithm);c||(this.emit("warn",`Invalid algorithm '${i.algorithm}' not found. Falling back to default algorithm '${this._defaultAlgorithm}'.`),c=new m({algorithm:this._defaultAlgorithm}));let f=await c.toHash(d);this._cache.enabled&&this._cache.set(a,f),s?.maxLength&&f.length>s?.maxLength&&(f=f.substring(0,s.maxLength));let l={hash:f,data:i.data,algorithm:i.algorithm};return await this.afterHook("toHash",l),l.hash}async toNumber(r,s={}){let{min:i=0,max:o=100,algorithm:a=this._defaultAlgorithm,hashLength:n=16}=s;if(i>o)throw new Error("min cannot be greater than max");let d=await this.toHash(r,{algorithm:a,maxLength:n}),c=Number.parseInt(d,16),f=o-i+1;return i+c%f}toHashSync(r,s){let i={data:r,algorithm:s?.algorithm??this._defaultAlgorithmSync,maxLength:s?.maxLength};this.beforeHook("toHashSync",i);let o=i.algorithm,a=this._stringify(i.data),n=`${o}:${a}`;if(this._cache.enabled){let g=this._cache.get(n);if(g!==void 0)return s?.maxLength&&g.length>s.maxLength?g.substring(0,s.maxLength):g}let c=new TextEncoder().encode(a),f=this._providers.get(o);if(!f&&(this.emit("warn",`Invalid algorithm '${o}' not found. Falling back to default algorithm '${this._defaultAlgorithmSync}'.`),f=this._providers.get(this._defaultAlgorithmSync),!f))throw new Error(`Hash provider '${this._defaultAlgorithmSync}' (default) not found`);if(!f.toHashSync)throw new Error(`Hash provider '${o}' does not support synchronous hashing. Use toHash() instead or choose a different algorithm (djb2, fnv1, murmer, crc32).`);let l=f.toHashSync(c);this._cache.enabled&&this._cache.set(n,l),s?.maxLength&&l.length>s?.maxLength&&(l=l.substring(0,s.maxLength));let u={hash:l,data:i.data,algorithm:i.algorithm};return this.afterHook("toHashSync",u),u.hash}toNumberSync(r,s={}){let{min:i=0,max:o=100,algorithm:a=this._defaultAlgorithmSync,hashLength:n=16}=s;if(i>o)throw new Error("min cannot be greater than max");let d=this.toHashSync(r,{algorithm:a,maxLength:n}),c=Number.parseInt(d,16),f=o-i+1;return i+c%f}loadProviders(r,s={includeBase:!0}){if(r)for(let i of r)this._providers.add(i);s.includeBase&&(this.providers.add(new m({algorithm:"SHA-256"})),this.providers.add(new m({algorithm:"SHA-384"})),this.providers.add(new m({algorithm:"SHA-512"})),this.providers.add(new y),this.providers.add(new _),this.providers.add(new H),this.providers.add(new b))}};})();
/* v8 ignore next -- @preserve */
/*! Bundled license information:

hookified/dist/node/index.js:
  (* v8 ignore next -- @preserve *)
*/
//# sourceMappingURL=index.global.js.map