{"version":3,"sources":["../../node_modules/.pnpm/hookified@1.14.0/node_modules/hookified/dist/node/index.js","../../src/cache.ts","../../src/providers/crc.ts","../../src/providers/crypto.ts","../../src/providers/djb2.ts","../../src/providers/fnv1.ts","../../src/providers/murmer.ts","../../src/providers.ts","../../src/index.ts"],"sourcesContent":["// src/eventified.ts\nvar Eventified = class {\n  _eventListeners;\n  _maxListeners;\n  _logger;\n  _throwOnEmitError = false;\n  _throwOnEmptyListeners = false;\n  _errorEvent = \"error\";\n  constructor(options) {\n    this._eventListeners = /* @__PURE__ */ new Map();\n    this._maxListeners = 100;\n    this._logger = options?.logger;\n    if (options?.throwOnEmitError !== void 0) {\n      this._throwOnEmitError = options.throwOnEmitError;\n    }\n    if (options?.throwOnEmptyListeners !== void 0) {\n      this._throwOnEmptyListeners = options.throwOnEmptyListeners;\n    }\n  }\n  /**\n   * Gets the logger\n   * @returns {Logger}\n   */\n  get logger() {\n    return this._logger;\n  }\n  /**\n   * Sets the logger\n   * @param {Logger} logger\n   */\n  set logger(logger) {\n    this._logger = logger;\n  }\n  /**\n   * Gets whether an error should be thrown when an emit throws an error. Default is false and only emits an error event.\n   * @returns {boolean}\n   */\n  get throwOnEmitError() {\n    return this._throwOnEmitError;\n  }\n  /**\n   * Sets whether an error should be thrown when an emit throws an error. Default is false and only emits an error event.\n   * @param {boolean} value\n   */\n  set throwOnEmitError(value) {\n    this._throwOnEmitError = value;\n  }\n  /**\n   * Gets whether an error should be thrown when emitting 'error' event with no listeners. Default is false.\n   * @returns {boolean}\n   */\n  get throwOnEmptyListeners() {\n    return this._throwOnEmptyListeners;\n  }\n  /**\n   * Sets whether an error should be thrown when emitting 'error' event with no listeners. Default is false.\n   * @param {boolean} value\n   */\n  set throwOnEmptyListeners(value) {\n    this._throwOnEmptyListeners = value;\n  }\n  /**\n   * Adds a handler function for a specific event that will run only once\n   * @param {string | symbol} eventName\n   * @param {EventListener} listener\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  once(eventName, listener) {\n    const onceListener = (...arguments_) => {\n      this.off(eventName, onceListener);\n      listener(...arguments_);\n    };\n    this.on(eventName, onceListener);\n    return this;\n  }\n  /**\n   * Gets the number of listeners for a specific event. If no event is provided, it returns the total number of listeners\n   * @param {string} eventName The event name. Not required\n   * @returns {number} The number of listeners\n   */\n  listenerCount(eventName) {\n    if (eventName === void 0) {\n      return this.getAllListeners().length;\n    }\n    const listeners = this._eventListeners.get(eventName);\n    return listeners ? listeners.length : 0;\n  }\n  /**\n   * Gets an array of event names\n   * @returns {Array<string | symbol>} An array of event names\n   */\n  eventNames() {\n    return [...this._eventListeners.keys()];\n  }\n  /**\n   * Gets an array of listeners for a specific event. If no event is provided, it returns all listeners\n   * @param {string} [event] (Optional) The event name\n   * @returns {EventListener[]} An array of listeners\n   */\n  rawListeners(event) {\n    if (event === void 0) {\n      return this.getAllListeners();\n    }\n    return this._eventListeners.get(event) ?? [];\n  }\n  /**\n   * Prepends a listener to the beginning of the listeners array for the specified event\n   * @param {string | symbol} eventName\n   * @param {EventListener} listener\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  prependListener(eventName, listener) {\n    const listeners = this._eventListeners.get(eventName) ?? [];\n    listeners.unshift(listener);\n    this._eventListeners.set(eventName, listeners);\n    return this;\n  }\n  /**\n   * Prepends a one-time listener to the beginning of the listeners array for the specified event\n   * @param {string | symbol} eventName\n   * @param {EventListener} listener\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  prependOnceListener(eventName, listener) {\n    const onceListener = (...arguments_) => {\n      this.off(eventName, onceListener);\n      listener(...arguments_);\n    };\n    this.prependListener(eventName, onceListener);\n    return this;\n  }\n  /**\n   * Gets the maximum number of listeners that can be added for a single event\n   * @returns {number} The maximum number of listeners\n   */\n  maxListeners() {\n    return this._maxListeners;\n  }\n  /**\n   * Adds a listener for a specific event. It is an alias for the on() method\n   * @param {string | symbol} event\n   * @param {EventListener} listener\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  addListener(event, listener) {\n    this.on(event, listener);\n    return this;\n  }\n  /**\n   * Adds a listener for a specific event\n   * @param {string | symbol} event\n   * @param {EventListener} listener\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  on(event, listener) {\n    if (!this._eventListeners.has(event)) {\n      this._eventListeners.set(event, []);\n    }\n    const listeners = this._eventListeners.get(event);\n    if (listeners) {\n      if (listeners.length >= this._maxListeners) {\n        console.warn(\n          `MaxListenersExceededWarning: Possible event memory leak detected. ${listeners.length + 1} ${event} listeners added. Use setMaxListeners() to increase limit.`\n        );\n      }\n      listeners.push(listener);\n    }\n    return this;\n  }\n  /**\n   * Removes a listener for a specific event. It is an alias for the off() method\n   * @param {string | symbol} event\n   * @param {EventListener} listener\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  removeListener(event, listener) {\n    this.off(event, listener);\n    return this;\n  }\n  /**\n   * Removes a listener for a specific event\n   * @param {string | symbol} event\n   * @param {EventListener} listener\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  off(event, listener) {\n    const listeners = this._eventListeners.get(event) ?? [];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n    if (listeners.length === 0) {\n      this._eventListeners.delete(event);\n    }\n    return this;\n  }\n  /**\n   * Calls all listeners for a specific event\n   * @param {string | symbol} event\n   * @param arguments_ The arguments to pass to the listeners\n   * @returns {boolean} Returns true if the event had listeners, false otherwise\n   */\n  emit(event, ...arguments_) {\n    let result = false;\n    const listeners = this._eventListeners.get(event);\n    if (listeners && listeners.length > 0) {\n      for (const listener of listeners) {\n        listener(...arguments_);\n        result = true;\n      }\n    }\n    if (event === this._errorEvent) {\n      const error = arguments_[0] instanceof Error ? arguments_[0] : new Error(`${arguments_[0]}`);\n      if (this._throwOnEmitError && !result) {\n        throw error;\n      } else {\n        if (this.listeners(this._errorEvent).length === 0 && this._throwOnEmptyListeners === true) {\n          throw error;\n        }\n      }\n    }\n    this.sendLog(event, arguments_);\n    return result;\n  }\n  /**\n   * Gets all listeners for a specific event. If no event is provided, it returns all listeners\n   * @param {string} [event] (Optional) The event name\n   * @returns {EventListener[]} An array of listeners\n   */\n  listeners(event) {\n    return this._eventListeners.get(event) ?? [];\n  }\n  /**\n   * Removes all listeners for a specific event. If no event is provided, it removes all listeners\n   * @param {string} [event] (Optional) The event name\n   * @returns {IEventEmitter} returns the instance of the class for chaining\n   */\n  removeAllListeners(event) {\n    if (event !== void 0) {\n      this._eventListeners.delete(event);\n    } else {\n      this._eventListeners.clear();\n    }\n    return this;\n  }\n  /**\n   * Sets the maximum number of listeners that can be added for a single event\n   * @param {number} n The maximum number of listeners\n   * @returns {void}\n   */\n  setMaxListeners(n) {\n    this._maxListeners = n;\n    for (const listeners of this._eventListeners.values()) {\n      if (listeners.length > n) {\n        listeners.splice(n);\n      }\n    }\n  }\n  /**\n   * Gets all listeners\n   * @returns {EventListener[]} An array of listeners\n   */\n  getAllListeners() {\n    let result = [];\n    for (const listeners of this._eventListeners.values()) {\n      result = [...result, ...listeners];\n    }\n    return result;\n  }\n  /**\n   * Sends a log message using the configured logger based on the event name\n   * @param {string | symbol} eventName - The event name that determines the log level\n   * @param {unknown} data - The data to log\n   */\n  sendLog(eventName, data) {\n    if (!this._logger) {\n      return;\n    }\n    let message;\n    if (typeof data === \"string\") {\n      message = data;\n    } else if (Array.isArray(data) && data.length > 0 && data[0] instanceof Error) {\n      message = data[0].message;\n    } else if (data instanceof Error) {\n      message = data.message;\n    } else if (Array.isArray(data) && data.length > 0 && typeof data[0]?.message === \"string\") {\n      message = data[0].message;\n    } else {\n      message = JSON.stringify(data);\n    }\n    switch (eventName) {\n      case \"error\": {\n        this._logger.error?.(message, { event: eventName, data });\n        break;\n      }\n      case \"warn\": {\n        this._logger.warn?.(message, { event: eventName, data });\n        break;\n      }\n      case \"trace\": {\n        this._logger.trace?.(message, { event: eventName, data });\n        break;\n      }\n      case \"debug\": {\n        this._logger.debug?.(message, { event: eventName, data });\n        break;\n      }\n      case \"fatal\": {\n        this._logger.fatal?.(message, { event: eventName, data });\n        break;\n      }\n      default: {\n        this._logger.info?.(message, { event: eventName, data });\n        break;\n      }\n    }\n  }\n};\n\n// src/index.ts\nvar Hookified = class extends Eventified {\n  _hooks;\n  _throwOnHookError = false;\n  _enforceBeforeAfter = false;\n  _deprecatedHooks;\n  _allowDeprecated = true;\n  constructor(options) {\n    super({\n      logger: options?.logger,\n      throwOnEmitError: options?.throwOnEmitError,\n      throwOnEmptyListeners: options?.throwOnEmptyListeners\n    });\n    this._hooks = /* @__PURE__ */ new Map();\n    this._deprecatedHooks = options?.deprecatedHooks ? new Map(options.deprecatedHooks) : /* @__PURE__ */ new Map();\n    if (options?.throwOnHookError !== void 0) {\n      this._throwOnHookError = options.throwOnHookError;\n    } else if (options?.throwHookErrors !== void 0) {\n      this._throwOnHookError = options.throwHookErrors;\n    }\n    if (options?.enforceBeforeAfter !== void 0) {\n      this._enforceBeforeAfter = options.enforceBeforeAfter;\n    }\n    if (options?.allowDeprecated !== void 0) {\n      this._allowDeprecated = options.allowDeprecated;\n    }\n  }\n  /**\n   * Gets all hooks\n   * @returns {Map<string, Hook[]>}\n   */\n  get hooks() {\n    return this._hooks;\n  }\n  /**\n   * Gets whether an error should be thrown when a hook throws an error. Default is false and only emits an error event.\n   * @returns {boolean}\n   * @deprecated - this will be deprecated in version 2. Please use throwOnHookError.\n   */\n  get throwHookErrors() {\n    return this._throwOnHookError;\n  }\n  /**\n   * Sets whether an error should be thrown when a hook throws an error. Default is false and only emits an error event.\n   * @param {boolean} value\n   * @deprecated - this will be deprecated in version 2. Please use throwOnHookError.\n   */\n  set throwHookErrors(value) {\n    this._throwOnHookError = value;\n  }\n  /**\n   * Gets whether an error should be thrown when a hook throws an error. Default is false and only emits an error event.\n   * @returns {boolean}\n   */\n  get throwOnHookError() {\n    return this._throwOnHookError;\n  }\n  /**\n   * Sets whether an error should be thrown when a hook throws an error. Default is false and only emits an error event.\n   * @param {boolean} value\n   */\n  set throwOnHookError(value) {\n    this._throwOnHookError = value;\n  }\n  /**\n   * Gets whether to enforce that all hook names start with 'before' or 'after'. Default is false.\n   * @returns {boolean}\n   * @default false\n   */\n  get enforceBeforeAfter() {\n    return this._enforceBeforeAfter;\n  }\n  /**\n   * Sets whether to enforce that all hook names start with 'before' or 'after'. Default is false.\n   * @param {boolean} value\n   */\n  set enforceBeforeAfter(value) {\n    this._enforceBeforeAfter = value;\n  }\n  /**\n   * Gets the map of deprecated hook names to deprecation messages.\n   * @returns {Map<string, string>}\n   */\n  get deprecatedHooks() {\n    return this._deprecatedHooks;\n  }\n  /**\n   * Sets the map of deprecated hook names to deprecation messages.\n   * @param {Map<string, string>} value\n   */\n  set deprecatedHooks(value) {\n    this._deprecatedHooks = value;\n  }\n  /**\n   * Gets whether deprecated hooks are allowed to be registered and executed. Default is true.\n   * @returns {boolean}\n   */\n  get allowDeprecated() {\n    return this._allowDeprecated;\n  }\n  /**\n   * Sets whether deprecated hooks are allowed to be registered and executed. Default is true.\n   * @param {boolean} value\n   */\n  set allowDeprecated(value) {\n    this._allowDeprecated = value;\n  }\n  /**\n   * Validates hook event name if enforceBeforeAfter is enabled\n   * @param {string} event - The event name to validate\n   * @throws {Error} If enforceBeforeAfter is true and event doesn't start with 'before' or 'after'\n   */\n  validateHookName(event) {\n    if (this._enforceBeforeAfter) {\n      const eventValue = event.trim().toLocaleLowerCase();\n      if (!eventValue.startsWith(\"before\") && !eventValue.startsWith(\"after\")) {\n        throw new Error(\n          `Hook event \"${event}\" must start with \"before\" or \"after\" when enforceBeforeAfter is enabled`\n        );\n      }\n    }\n  }\n  /**\n   * Checks if a hook is deprecated and emits a warning if it is\n   * @param {string} event - The event name to check\n   * @returns {boolean} - Returns true if the hook should proceed, false if it should be blocked\n   */\n  checkDeprecatedHook(event) {\n    if (this._deprecatedHooks.has(event)) {\n      const message = this._deprecatedHooks.get(event);\n      const warningMessage = `Hook \"${event}\" is deprecated${message ? `: ${message}` : \"\"}`;\n      this.emit(\"warn\", { hook: event, message: warningMessage });\n      return this._allowDeprecated;\n    }\n    return true;\n  }\n  /**\n   * Adds a handler function for a specific event\n   * @param {string} event\n   * @param {Hook} handler - this can be async or sync\n   * @returns {void}\n   */\n  onHook(event, handler) {\n    this.validateHookName(event);\n    if (!this.checkDeprecatedHook(event)) {\n      return;\n    }\n    const eventHandlers = this._hooks.get(event);\n    if (eventHandlers) {\n      eventHandlers.push(handler);\n    } else {\n      this._hooks.set(event, [handler]);\n    }\n  }\n  /**\n   * Adds a handler function for a specific event that runs before all other handlers\n   * @param {HookEntry} hookEntry\n   * @returns {void}\n   */\n  onHookEntry(hookEntry) {\n    this.onHook(hookEntry.event, hookEntry.handler);\n  }\n  /**\n   * Alias for onHook. This is provided for compatibility with other libraries that use the `addHook` method.\n   * @param {string} event\n   * @param {Hook} handler - this can be async or sync\n   * @returns {void}\n   */\n  addHook(event, handler) {\n    this.onHook(event, handler);\n  }\n  /**\n   * Adds a handler function for a specific event\n   * @param {Array<HookEntry>} hooks\n   * @returns {void}\n   */\n  onHooks(hooks) {\n    for (const hook of hooks) {\n      this.onHook(hook.event, hook.handler);\n    }\n  }\n  /**\n   * Adds a handler function for a specific event that runs before all other handlers\n   * @param {string} event\n   * @param {Hook} handler - this can be async or sync\n   * @returns {void}\n   */\n  prependHook(event, handler) {\n    this.validateHookName(event);\n    if (!this.checkDeprecatedHook(event)) {\n      return;\n    }\n    const eventHandlers = this._hooks.get(event);\n    if (eventHandlers) {\n      eventHandlers.unshift(handler);\n    } else {\n      this._hooks.set(event, [handler]);\n    }\n  }\n  /**\n   * Adds a handler that only executes once for a specific event before all other handlers\n   * @param event\n   * @param handler\n   */\n  prependOnceHook(event, handler) {\n    this.validateHookName(event);\n    if (!this.checkDeprecatedHook(event)) {\n      return;\n    }\n    const hook = async (...arguments_) => {\n      this.removeHook(event, hook);\n      return handler(...arguments_);\n    };\n    this.prependHook(event, hook);\n  }\n  /**\n   * Adds a handler that only executes once for a specific event\n   * @param event\n   * @param handler\n   */\n  onceHook(event, handler) {\n    this.validateHookName(event);\n    if (!this.checkDeprecatedHook(event)) {\n      return;\n    }\n    const hook = async (...arguments_) => {\n      this.removeHook(event, hook);\n      return handler(...arguments_);\n    };\n    this.onHook(event, hook);\n  }\n  /**\n   * Removes a handler function for a specific event\n   * @param {string} event\n   * @param {Hook} handler\n   * @returns {void}\n   */\n  removeHook(event, handler) {\n    this.validateHookName(event);\n    if (!this.checkDeprecatedHook(event)) {\n      return;\n    }\n    const eventHandlers = this._hooks.get(event);\n    if (eventHandlers) {\n      const index = eventHandlers.indexOf(handler);\n      if (index !== -1) {\n        eventHandlers.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Removes all handlers for a specific event\n   * @param {Array<HookEntry>} hooks\n   * @returns {void}\n   */\n  removeHooks(hooks) {\n    for (const hook of hooks) {\n      this.removeHook(hook.event, hook.handler);\n    }\n  }\n  /**\n   * Calls all handlers for a specific event\n   * @param {string} event\n   * @param {T[]} arguments_\n   * @returns {Promise<void>}\n   */\n  async hook(event, ...arguments_) {\n    this.validateHookName(event);\n    if (!this.checkDeprecatedHook(event)) {\n      return;\n    }\n    const eventHandlers = this._hooks.get(event);\n    if (eventHandlers) {\n      for (const handler of eventHandlers) {\n        try {\n          await handler(...arguments_);\n        } catch (error) {\n          const message = `${event}: ${error.message}`;\n          this.emit(\"error\", new Error(message));\n          if (this._throwOnHookError) {\n            throw new Error(message);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Prepends the word `before` to your hook. Example is event is `test`, the before hook is `before:test`.\n   * @param {string} event - The event name\n   * @param {T[]} arguments_ - The arguments to pass to the hook\n   */\n  async beforeHook(event, ...arguments_) {\n    await this.hook(`before:${event}`, ...arguments_);\n  }\n  /**\n   * Prepends the word `after` to your hook. Example is event is `test`, the after hook is `after:test`.\n   * @param {string} event - The event name\n   * @param {T[]} arguments_ - The arguments to pass to the hook\n   */\n  async afterHook(event, ...arguments_) {\n    await this.hook(`after:${event}`, ...arguments_);\n  }\n  /**\n   * Calls all handlers for a specific event. This is an alias for `hook` and is provided for\n   * compatibility with other libraries that use the `callHook` method.\n   * @param {string} event\n   * @param {T[]} arguments_\n   * @returns {Promise<void>}\n   */\n  async callHook(event, ...arguments_) {\n    await this.hook(event, ...arguments_);\n  }\n  /**\n   * Gets all hooks for a specific event\n   * @param {string} event\n   * @returns {Hook[]}\n   */\n  getHooks(event) {\n    this.validateHookName(event);\n    if (!this.checkDeprecatedHook(event)) {\n      return void 0;\n    }\n    return this._hooks.get(event);\n  }\n  /**\n   * Removes all hooks\n   * @returns {void}\n   */\n  clearHooks() {\n    this._hooks.clear();\n  }\n};\nexport {\n  Eventified,\n  Hookified\n};\n/* v8 ignore next -- @preserve */\n","/**\n * Configuration options for the Cache class.\n */\nexport type CacheOptions = {\n\t/**\n\t * Enable or disable the cache.\n\t * Defaults to true (enabled).\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * Maximum number of items to store in the cache.\n\t * Defaults to 4000. When limit is reached, oldest entries are evicted (FIFO).\n\t *\n\t * Note: JavaScript Map can hold up to 2^24 (~16.7 million) entries in most\n\t * environments, but practical limits depend on available memory and key/value sizes.\n\t * For hash caching, 4000-10000 entries is typically sufficient for most use cases.\n\t */\n\tmaxSize?: number;\n};\n\n/**\n * A simple FIFO (First In, First Out) cache for storing hash values.\n * When the cache reaches its maximum size, the oldest entries are evicted.\n *\n * The cache uses a JavaScript Map internally, which can theoretically hold up to\n * 2^24 (~16.7 million) entries. However, practical limits depend on available memory\n * and the size of cached keys/values. The default maxSize of 4000 provides a good\n * balance between performance and memory usage for typical hash caching scenarios.\n */\nexport class Cache {\n\tprivate _enabled = true;\n\tprivate _maxSize = 4000;\n\tprivate _store = new Map<string, string>();\n\tprivate _keys: string[] = [];\n\n\tconstructor(options?: CacheOptions) {\n\t\tif (options?.enabled !== undefined) {\n\t\t\tthis._enabled = options.enabled;\n\t\t}\n\n\t\tif (options?.maxSize !== undefined) {\n\t\t\tthis._maxSize = options.maxSize;\n\t\t}\n\t}\n\n\t/**\n\t * Gets whether the cache is enabled.\n\t */\n\tpublic get enabled(): boolean {\n\t\treturn this._enabled;\n\t}\n\n\t/**\n\t * Sets whether the cache is enabled.\n\t */\n\tpublic set enabled(value: boolean) {\n\t\tthis._enabled = value;\n\t}\n\n\t/**\n\t * Gets the maximum number of items the cache can hold.\n\t */\n\tpublic get maxSize(): number {\n\t\treturn this._maxSize;\n\t}\n\n\t/**\n\t * Sets the maximum number of items the cache can hold.\n\t */\n\tpublic set maxSize(value: number) {\n\t\tthis._maxSize = value;\n\t}\n\n\t/**\n\t * Gets the underlying Map store.\n\t */\n\tpublic get store(): Map<string, string> {\n\t\treturn this._store;\n\t}\n\n\t/**\n\t * Gets the current number of items in the cache.\n\t */\n\tpublic get size(): number {\n\t\treturn this._store.size;\n\t}\n\n\t/**\n\t * Gets a value from the cache.\n\t * @param key - The cache key\n\t * @returns The cached value, or undefined if not found\n\t */\n\tpublic get(key: string): string | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\t/**\n\t * Sets a value in the cache with FIFO eviction.\n\t * If the cache is disabled, this method does nothing.\n\t * If the cache is at capacity, the oldest entry is removed before adding the new one.\n\t * @param key - The cache key\n\t * @param value - The value to cache\n\t */\n\tpublic set(key: string, value: string): void {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If key already exists, just update the value\n\t\tif (this._store.has(key)) {\n\t\t\tthis._store.set(key, value);\n\t\t\treturn;\n\t\t}\n\n\t\t// If at capacity, remove oldest (FIFO)\n\t\tif (this._store.size >= this._maxSize) {\n\t\t\tconst oldestKey = this._keys.shift();\n\t\t\t/* v8 ignore next -- @preserve */\n\t\t\tif (oldestKey) {\n\t\t\t\tthis._store.delete(oldestKey);\n\t\t\t}\n\t\t}\n\n\t\t// Add new entry\n\t\tthis._keys.push(key);\n\t\tthis._store.set(key, value);\n\t}\n\n\t/**\n\t * Checks if a key exists in the cache.\n\t * @param key - The cache key\n\t * @returns True if the key exists, false otherwise\n\t */\n\tpublic has(key: string): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\t/**\n\t * Clears all entries from the cache.\n\t */\n\tpublic clear(): void {\n\t\tthis._store.clear();\n\t\tthis._keys = [];\n\t}\n}\n","import type { HashProvider } from \"../types.ts\";\n\nexport class CRC implements HashProvider {\n    public get name(): string {\n        return \"crc32\";\n    }\n\n    public toHashSync(data: BufferSource): string {\n        // Convert BufferSource to Uint8Array\n        let bytes: Uint8Array;\n\n        if (data instanceof Uint8Array) {\n            bytes = data;\n        } else if (data instanceof ArrayBuffer) {\n            bytes = new Uint8Array(data);\n        } else if (data instanceof DataView) {\n            bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        } else {\n            const view = data as ArrayBufferView;\n            bytes = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n        }\n\n        // CRC-32 algorithm (IEEE 802.3 polynomial)\n        // This is the same algorithm used by PHP's crc32() function\n        const CRC32_POLYNOMIAL = 0xEDB88320;\n        let crc = 0xFFFFFFFF;\n\n        for (let i = 0; i < bytes.length; i++) {\n            crc = crc ^ bytes[i];\n            for (let j = 0; j < 8; j++) {\n                crc = (crc >>> 1) ^ (CRC32_POLYNOMIAL & -(crc & 1));\n            }\n        }\n\n        // Finalize CRC\n        crc = (crc ^ 0xFFFFFFFF) >>> 0;\n\n        // Convert to hexadecimal string (8 characters, zero-padded)\n        const hashHex = crc.toString(16).padStart(8, \"0\");\n        return hashHex;\n    }\n\n    public async toHash(data: BufferSource): Promise<string> {\n        return this.toHashSync(data);\n    }\n}\n","import type { WebCryptoHashAlgorithm, HashProvider } from \"../types.js\";\n\n\nexport type WebCryptoOptions = {\n\talgorithm?: WebCryptoHashAlgorithm\n}\n\nexport class WebCrypto implements HashProvider {\n\tprivate _algorithm: WebCryptoHashAlgorithm = \"SHA-256\";\n\tconstructor(options?: WebCryptoOptions) {\n\t\tif(options?.algorithm) {\n\t\t\tthis._algorithm = options?.algorithm;\n\t\t}\n\n\t}\n\n\tpublic get name(): string {\n\t\treturn this._algorithm;\n\t}\n\n\tpublic async toHash(data: BufferSource): Promise<string> {\n\t\t// Hash the data using Web Crypto API\n\t\tconst hashBuffer = await crypto.subtle.digest(this._algorithm, data);\n\n\t\t// Convert the hash to a hexadecimal string\n\t\tconst hashArray = Array.from(new Uint8Array(hashBuffer));\n\t\tconst hashHex = hashArray\n\t\t\t.map((byte) => byte.toString(16).padStart(2, \"0\"))\n\t\t\t.join(\"\");\n\n\t\treturn hashHex;\n\t}\n}","import type { HashProvider } from \"../types.ts\";\n\n/**\n * DJB2 hash algorithm implementation.\n *\n * DJB2 is a non-cryptographic hash function created by Daniel J. Bernstein.\n * It produces a 32-bit hash value, making it suitable for hash tables and checksums,\n * but NOT for cryptographic purposes.\n *\n * Algorithm: hash = hash * 33 + c (where c is each byte)\n * Initial value: 5381\n *\n * @example\n * ```typescript\n * import { Hashery } from 'hashery';\n * import { DJB2 } from 'hashery/providers/djb2';\n *\n * const hashery = new Hashery();\n * hashery.providers.add(new DJB2());\n *\n * const hash = await hashery.toHash({ data: 'hello' }, 'djb2');\n * console.log(hash); // \"7c9df5ea\"\n * ```\n */\nexport class DJB2 implements HashProvider {\n\t/**\n\t * The name identifier for this hash provider.\n\t */\n\tpublic get name(): string {\n\t\treturn \"djb2\";\n\t}\n\n\t/**\n\t * Computes the DJB2 hash of the provided data synchronously.\n\t *\n\t * @param data - The data to hash (Uint8Array, ArrayBuffer, or DataView)\n\t * @returns An 8-character lowercase hexadecimal string\n\t *\n\t * @example\n\t * ```typescript\n\t * const djb2 = new DJB2();\n\t * const data = new TextEncoder().encode('hello');\n\t * const hash = djb2.toHashSync(data);\n\t * console.log(hash); // \"7c9df5ea\"\n\t * ```\n\t */\n\tpublic toHashSync(data: BufferSource): string {\n\t\t// Convert BufferSource to Uint8Array for consistent processing\n\t\tlet bytes: Uint8Array;\n\n\t\tif (data instanceof Uint8Array) {\n\t\t\tbytes = data;\n\t\t} else if (data instanceof ArrayBuffer) {\n\t\t\tbytes = new Uint8Array(data);\n\t\t} else if (data instanceof DataView) {\n\t\t\tbytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n\t\t} else {\n\t\t\t// Fallback for other ArrayBufferView types (e.g., Int8Array, Uint16Array, etc.)\n\t\t\tconst view = data as ArrayBufferView;\n\t\t\tbytes = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n\t\t}\n\n\t\t// DJB2 algorithm\n\t\t// Initial hash value: 5381\n\t\tlet hash = 5381;\n\n\t\t// Process each byte: hash = hash * 33 + byte\n\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\thash = ((hash << 5) + hash) + bytes[i]; // hash * 33 + c\n\t\t\t// Keep it as a 32-bit unsigned integer\n\t\t\thash = hash >>> 0;\n\t\t}\n\n\t\t// Convert to 8-character lowercase hexadecimal string\n\t\tconst hashHex = hash.toString(16).padStart(8, \"0\");\n\n\t\treturn hashHex;\n\t}\n\n\t/**\n\t * Computes the DJB2 hash of the provided data.\n\t *\n\t * @param data - The data to hash (Uint8Array, ArrayBuffer, or DataView)\n\t * @returns A Promise resolving to an 8-character lowercase hexadecimal string\n\t *\n\t * @example\n\t * ```typescript\n\t * const djb2 = new DJB2();\n\t * const data = new TextEncoder().encode('hello');\n\t * const hash = await djb2.toHash(data);\n\t * console.log(hash); // \"7c9df5ea\"\n\t * ```\n\t */\n\tpublic async toHash(data: BufferSource): Promise<string> {\n\t\treturn this.toHashSync(data);\n\t}\n}\n","import type { HashProvider } from \"../types.ts\";\n\n/**\n * FNV-1 (Fowler-Noll-Vo) hash algorithm implementation.\n *\n * FNV-1 is a non-cryptographic hash function created by Glenn Fowler, Landon Curt Noll,\n * and Kiem-Phong Vo. It produces a 32-bit hash value, making it suitable for hash tables\n * and checksums, but NOT for cryptographic purposes.\n *\n * Algorithm: hash = (hash * FNV_prime) XOR octet_of_data\n * FNV-1 32-bit offset basis: 2166136261\n * FNV-1 32-bit prime: 16777619\n */\nexport class FNV1 implements HashProvider {\n    /**\n     * The name identifier for this hash provider.\n     */\n    public get name(): string {\n        return \"fnv1\";\n    }\n\n    /**\n     * Computes the FNV-1 hash of the provided data synchronously.\n     *\n     * @param data - The data to hash (Uint8Array, ArrayBuffer, or DataView)\n     * @returns An 8-character lowercase hexadecimal string\n     */\n    public toHashSync(data: BufferSource): string {\n        // Convert BufferSource to Uint8Array for consistent processing\n        let bytes: Uint8Array;\n\n        if (data instanceof Uint8Array) {\n            bytes = data;\n        } else if (data instanceof ArrayBuffer) {\n            bytes = new Uint8Array(data);\n        } else if (data instanceof DataView) {\n            bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        } else {\n            // Fallback for other ArrayBufferView types (e.g., Int8Array, Uint16Array, etc.)\n            const view = data as ArrayBufferView;\n            bytes = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n        }\n\n        // FNV-1 algorithm constants\n        const FNV_OFFSET_BASIS = 2166136261; // 32-bit offset basis\n        const FNV_PRIME = 16777619; // 32-bit FNV prime\n\n        // Initialize hash with FNV offset basis\n        let hash = FNV_OFFSET_BASIS;\n\n        // Process each byte: hash = (hash * FNV_prime) XOR byte\n        for (let i = 0; i < bytes.length; i++) {\n            hash = hash * FNV_PRIME;\n            hash = hash ^ bytes[i];\n            // Keep it as a 32-bit unsigned integer\n            hash = hash >>> 0;\n        }\n\n        // Convert to 8-character lowercase hexadecimal string\n        const hashHex = hash.toString(16).padStart(8, \"0\");\n\n        return hashHex;\n    }\n\n    /**\n     * Computes the FNV-1 hash of the provided data.\n     *\n     * @param data - The data to hash (Uint8Array, ArrayBuffer, or DataView)\n     * @returns A Promise resolving to an 8-character lowercase hexadecimal string\n     */\n    public async toHash(data: BufferSource): Promise<string> {\n        return this.toHashSync(data);\n    }\n}\n","import type { HashProvider } from \"../types.ts\";\n\n/**\n * Murmer 32-bit hash algorithm implementation.\n *\n * Murmer is a non-cryptographic hash function based on MurmurHash3 by Austin Appleby.\n * It produces a 32-bit hash value with excellent distribution and performance,\n * making it suitable for hash tables, bloom filters, and checksums,\n * but NOT for cryptographic purposes.\n *\n * This implementation uses the MurmurHash3_x86_32 variant.\n *\n * @example\n * ```typescript\n * import { Hashery } from 'hashery';\n * import { Murmer } from 'hashery/providers/murmer';\n *\n * const hashery = new Hashery();\n * hashery.providers.add(new Murmer());\n *\n * const hash = await hashery.toHash({ data: 'hello' }, 'murmer');\n * console.log(hash); // \"248bfa47\"\n * ```\n */\nexport class Murmer implements HashProvider {\n\tprivate _seed: number;\n\n\t/**\n\t * Creates a new Murmer instance.\n\t *\n\t * @param seed - Optional seed value for the hash (default: 0)\n\t */\n\tconstructor(seed: number = 0) {\n\t\tthis._seed = seed >>> 0; // Ensure it's a 32-bit unsigned integer\n\t}\n\n\t/**\n\t * The name identifier for this hash provider.\n\t */\n\tpublic get name(): string {\n\t\treturn \"murmer\";\n\t}\n\n\t/**\n\t * Gets the current seed value used for hashing.\n\t */\n\tpublic get seed(): number {\n\t\treturn this._seed;\n\t}\n\n\t/**\n\t * Computes the Murmer 32-bit hash of the provided data synchronously.\n\t *\n\t * @param data - The data to hash (Uint8Array, ArrayBuffer, or DataView)\n\t * @returns An 8-character lowercase hexadecimal string\n\t *\n\t * @example\n\t * ```typescript\n\t * const murmer = new Murmer();\n\t * const data = new TextEncoder().encode('hello');\n\t * const hash = murmer.toHashSync(data);\n\t * console.log(hash); // \"248bfa47\"\n\t * ```\n\t */\n\tpublic toHashSync(data: BufferSource): string {\n\t\t// Convert BufferSource to Uint8Array for consistent processing\n\t\tlet bytes: Uint8Array;\n\n\t\tif (data instanceof Uint8Array) {\n\t\t\tbytes = data;\n\t\t} else if (data instanceof ArrayBuffer) {\n\t\t\tbytes = new Uint8Array(data);\n\t\t} else if (data instanceof DataView) {\n\t\t\tbytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n\t\t} else {\n\t\t\t// Fallback for other ArrayBufferView types (e.g., Int8Array, Uint16Array, etc.)\n\t\t\tconst view = data as ArrayBufferView;\n\t\t\tbytes = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n\t\t}\n\n\t\t// MurmurHash3_x86_32 algorithm\n\t\tconst c1 = 0xcc9e2d51;\n\t\tconst c2 = 0x1b873593;\n\t\tconst length = bytes.length;\n\t\tconst nblocks = Math.floor(length / 4);\n\n\t\tlet h1 = this._seed;\n\n\t\t// Process 4-byte blocks\n\t\tfor (let i = 0; i < nblocks; i++) {\n\t\t\tconst index = i * 4;\n\t\t\tlet k1 =\n\t\t\t\t(bytes[index] & 0xff) |\n\t\t\t\t((bytes[index + 1] & 0xff) << 8) |\n\t\t\t\t((bytes[index + 2] & 0xff) << 16) |\n\t\t\t\t((bytes[index + 3] & 0xff) << 24);\n\n\t\t\tk1 = this._imul(k1, c1);\n\t\t\tk1 = this._rotl32(k1, 15);\n\t\t\tk1 = this._imul(k1, c2);\n\n\t\t\th1 ^= k1;\n\t\t\th1 = this._rotl32(h1, 13);\n\t\t\th1 = this._imul(h1, 5) + 0xe6546b64;\n\t\t}\n\n\t\t// Process remaining bytes\n\t\tconst tail = nblocks * 4;\n\t\tlet k1 = 0;\n\n\t\tswitch (length & 3) {\n\t\t\tcase 3:\n\t\t\t\tk1 ^= (bytes[tail + 2] & 0xff) << 16;\n\t\t\t// fallthrough\n\t\t\tcase 2:\n\t\t\t\tk1 ^= (bytes[tail + 1] & 0xff) << 8;\n\t\t\t// fallthrough\n\t\t\tcase 1:\n\t\t\t\tk1 ^= bytes[tail] & 0xff;\n\t\t\t\tk1 = this._imul(k1, c1);\n\t\t\t\tk1 = this._rotl32(k1, 15);\n\t\t\t\tk1 = this._imul(k1, c2);\n\t\t\t\th1 ^= k1;\n\t\t}\n\n\t\t// Finalization\n\t\th1 ^= length;\n\n\t\th1 ^= h1 >>> 16;\n\t\th1 = this._imul(h1, 0x85ebca6b);\n\t\th1 ^= h1 >>> 13;\n\t\th1 = this._imul(h1, 0xc2b2ae35);\n\t\th1 ^= h1 >>> 16;\n\n\t\t// Convert to unsigned 32-bit integer\n\t\th1 = h1 >>> 0;\n\n\t\t// Convert to 8-character lowercase hexadecimal string\n\t\tconst hashHex = h1.toString(16).padStart(8, \"0\");\n\n\t\treturn hashHex;\n\t}\n\n\t/**\n\t * Computes the Murmer 32-bit hash of the provided data.\n\t *\n\t * @param data - The data to hash (Uint8Array, ArrayBuffer, or DataView)\n\t * @returns A Promise resolving to an 8-character lowercase hexadecimal string\n\t *\n\t * @example\n\t * ```typescript\n\t * const murmer = new Murmer();\n\t * const data = new TextEncoder().encode('hello');\n\t * const hash = await murmer.toHash(data);\n\t * console.log(hash); // \"248bfa47\"\n\t * ```\n\t */\n\tpublic async toHash(data: BufferSource): Promise<string> {\n\t\treturn this.toHashSync(data);\n\t}\n\n\t/**\n\t * 32-bit integer multiplication with proper overflow handling.\n\t * @private\n\t */\n\tprivate _imul(a: number, b: number): number {\n\t\t// Use Math.imul if available, otherwise fallback to manual implementation\n\t\t/* v8 ignore next -- @preserve */\n\t\tif (Math.imul) {\n\t\t\treturn Math.imul(a, b);\n\t\t}\n\n\t\t// Manual 32-bit multiplication\n\t\t/* v8 ignore next -- @preserve */\n\t\tconst ah = (a >>> 16) & 0xffff;\n\t\t/* v8 ignore next -- @preserve */\n\t\tconst al = a & 0xffff;\n\t\t/* v8 ignore next -- @preserve */\n\t\tconst bh = (b >>> 16) & 0xffff;\n\t\t/* v8 ignore next -- @preserve */\n\t\tconst bl = b & 0xffff;\n\n\t\t/* v8 ignore next -- @preserve */\n\t\treturn ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)) | 0;\n\t}\n\n\t/**\n\t * Left rotate a 32-bit integer.\n\t * @private\n\t */\n\tprivate _rotl32(x: number, r: number): number {\n\t\treturn (x << r) | (x >>> (32 - r));\n\t}\n}\n","import type {\n\tHashProvider,\n\tHashProvidersGetOptions,\n\tHashProvidersOptions,\n} from \"./types.js\";\n\n/**\n * Manages a collection of hash providers for the Hashery system.\n * Provides methods to add, remove, and load multiple hash providers.\n */\nexport class HashProviders {\n\tprivate _providers: Map<string, HashProvider> = new Map();\n\tprivate _getFuzzy = true;\n\n\t/**\n\t * Creates a new HashProviders instance.\n\t * @param options - Optional configuration including initial providers to load\n\t * @example\n\t * ```ts\n\t * const providers = new HashProviders({\n\t *   providers: [{ name: 'custom', toHash: async (data) => '...' }]\n\t * });\n\t * ```\n\t */\n\tconstructor(options?: HashProvidersOptions) {\n\t\tif (options?.providers) {\n\t\t\tthis.loadProviders(options?.providers);\n\t\t}\n\n\t\tif (options?.getFuzzy !== undefined) {\n\t\t\tthis._getFuzzy = Boolean(options?.getFuzzy);\n\t\t}\n\t}\n\n\t/**\n\t * Loads multiple hash providers at once.\n\t * Each provider is added to the internal map using its name as the key.\n\t * @param providers - Array of HashProvider objects to load\n\t * @example\n\t * ```ts\n\t * const providers = new HashProviders();\n\t * providers.loadProviders([\n\t *   { name: 'md5', toHash: async (data) => '...' },\n\t *   { name: 'sha1', toHash: async (data) => '...' }\n\t * ]);\n\t * ```\n\t */\n\tpublic loadProviders(providers: Array<HashProvider>) {\n\t\tfor (const provider of providers) {\n\t\t\tthis._providers.set(provider.name, provider);\n\t\t}\n\t}\n\n\t/**\n\t * Gets the internal Map of all registered hash providers.\n\t * @returns Map of provider names to HashProvider objects\n\t */\n\tpublic get providers(): Map<string, HashProvider> {\n\t\treturn this._providers;\n\t}\n\n\t/**\n\t * Sets the internal Map of hash providers, replacing all existing providers.\n\t * @param providers - Map of provider names to HashProvider objects\n\t */\n\tpublic set providers(providers: Map<string, HashProvider>) {\n\t\tthis._providers = providers;\n\t}\n\n\t/**\n\t * Gets an array of all provider names.\n\t * @returns Array of provider names\n\t * @example\n\t * ```ts\n\t * const providers = new HashProviders();\n\t * providers.add({ name: 'sha256', toHash: async (data) => '...' });\n\t * providers.add({ name: 'md5', toHash: async (data) => '...' });\n\t * console.log(providers.names); // ['sha256', 'md5']\n\t * ```\n\t */\n\tpublic get names(): Array<string> {\n\t\treturn Array.from(this._providers.keys());\n\t}\n\n\t/**\n\t * Gets a hash provider by name with optional fuzzy matching.\n\t *\n\t * Fuzzy matching (enabled by default) attempts to find providers by:\n\t * 1. Exact match (after trimming whitespace)\n\t * 2. Case-insensitive match (lowercase)\n\t * 3. Dash-removed match (e.g., \"SHA-256\" matches \"sha256\")\n\t *\n\t * @param name - The name of the provider to retrieve\n\t * @param options - Optional configuration for the get operation\n\t * @param options.fuzzy - Enable/disable fuzzy matching (overrides constructor setting)\n\t * @returns The HashProvider if found, undefined otherwise\n\t * @example\n\t * ```ts\n\t * const providers = new HashProviders();\n\t * providers.add({ name: 'sha256', toHash: async (data) => '...' });\n\t *\n\t * // Exact match\n\t * const provider = providers.get('sha256');\n\t *\n\t * // Fuzzy match (case-insensitive)\n\t * const provider2 = providers.get('SHA256');\n\t *\n\t * // Fuzzy match (with dash)\n\t * const provider3 = providers.get('SHA-256');\n\t *\n\t * // Disable fuzzy matching\n\t * const provider4 = providers.get('SHA256', { fuzzy: false }); // returns undefined\n\t * ```\n\t */\n\tpublic get(\n\t\tname: string,\n\t\toptions?: HashProvidersGetOptions,\n\t): HashProvider | undefined {\n\t\t// set the options\n\t\tconst getFuzzy = options?.fuzzy ?? this._getFuzzy;\n\n\t\t// do the trim\n\t\tname = name.trim();\n\n\t\tlet result = this._providers.get(name);\n\n\t\t// try with lower case\n\t\tif (result === undefined && getFuzzy === true) {\n\t\t\tname = name.toLowerCase();\n\t\t\tresult = this._providers.get(name);\n\t\t}\n\n\t\t// try removing dash\n\t\tif (result === undefined && getFuzzy === true) {\n\t\t\tname = name.replaceAll(\"-\", \"\");\n\t\t\tresult = this._providers.get(name);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Adds a single hash provider to the collection.\n\t * If a provider with the same name already exists, it will be replaced.\n\t * @param provider - The HashProvider object to add\n\t * @example\n\t * ```ts\n\t * const providers = new HashProviders();\n\t * providers.add({\n\t *   name: 'custom-hash',\n\t *   toHash: async (data) => {\n\t *     // Custom hashing logic\n\t *     return 'hash-result';\n\t *   }\n\t * });\n\t * ```\n\t */\n\tpublic add(provider: HashProvider): void {\n\t\tthis._providers.set(provider.name, provider);\n\t}\n\n\t/**\n\t * Removes a hash provider from the collection by name.\n\t * @param name - The name of the provider to remove\n\t * @returns true if the provider was found and removed, false otherwise\n\t * @example\n\t * ```ts\n\t * const providers = new HashProviders();\n\t * providers.add({ name: 'custom', toHash: async (data) => '...' });\n\t * const removed = providers.remove('custom'); // returns true\n\t * const removed2 = providers.remove('nonexistent'); // returns false\n\t * ```\n\t */\n\tpublic remove(name: string): boolean {\n\t\treturn this._providers.delete(name);\n\t}\n}\n","import { Hookified } from \"hookified\";\nimport { Cache } from \"./cache.js\";\nimport { CRC } from \"./providers/crc.js\";\nimport { WebCrypto } from \"./providers/crypto.js\";\nimport { DJB2 } from \"./providers/djb2.js\";\nimport { FNV1 } from \"./providers/fnv1.js\";\nimport { Murmer } from \"./providers/murmer.js\";\nimport { HashProviders } from \"./providers.js\";\nimport type {\n\tHasheryLoadProviderOptions,\n\tHasheryOptions,\n\tHasheryToHashOptions,\n\tHasheryToHashSyncOptions,\n\tHasheryToNumberOptions,\n\tHasheryToNumberSyncOptions,\n\tHashProvider,\n\tParseFn,\n\tStringifyFn,\n\tWebCryptoHashAlgorithm,\n} from \"./types.js\";\n\nexport class Hashery extends Hookified {\n\tprivate _parse: ParseFn = JSON.parse;\n\tprivate _stringify: StringifyFn = JSON.stringify;\n\tprivate _providers = new HashProviders();\n\tprivate _defaultAlgorithm: string = \"SHA-256\";\n\tprivate _defaultAlgorithmSync: string = \"djb2\";\n\tprivate _cache: Cache;\n\n\tconstructor(options?: HasheryOptions) {\n\t\tsuper(options);\n\n\t\tif (options?.parse) {\n\t\t\tthis._parse = options.parse;\n\t\t}\n\n\t\tif (options?.stringify) {\n\t\t\tthis._stringify = options.stringify;\n\t\t}\n\n\t\tif (options?.defaultAlgorithm) {\n\t\t\tthis._defaultAlgorithm = options.defaultAlgorithm;\n\t\t}\n\n\t\tif (options?.defaultAlgorithmSync) {\n\t\t\tthis._defaultAlgorithmSync = options.defaultAlgorithmSync;\n\t\t}\n\n\t\tthis._cache = new Cache(options?.cache);\n\n\t\tthis.loadProviders(options?.providers, {\n\t\t\tincludeBase: options?.includeBase ?? true,\n\t\t});\n\t}\n\n\t/**\n\t * Gets the parse function used to deserialize stored values.\n\t * @returns The current parse function (defaults to JSON.parse)\n\t */\n\tpublic get parse(): ParseFn {\n\t\treturn this._parse;\n\t}\n\n\t/**\n\t * Sets the parse function used to deserialize stored values.\n\t * @param value - The parse function to use for deserialization\n\t */\n\tpublic set parse(value: ParseFn) {\n\t\tthis._parse = value;\n\t}\n\n\t/**\n\t * Gets the stringify function used to serialize values for storage.\n\t * @returns The current stringify function (defaults to JSON.stringify)\n\t */\n\tpublic get stringify(): StringifyFn {\n\t\treturn this._stringify;\n\t}\n\n\t/**\n\t * Sets the stringify function used to serialize values for storage.\n\t * @param value - The stringify function to use for serialization\n\t */\n\tpublic set stringify(value: StringifyFn) {\n\t\tthis._stringify = value;\n\t}\n\n\t/**\n\t * Gets the HashProviders instance used to manage hash providers.\n\t * @returns The current HashProviders instance\n\t */\n\tpublic get providers(): HashProviders {\n\t\treturn this._providers;\n\t}\n\n\t/**\n\t * Sets the HashProviders instance used to manage hash providers.\n\t * @param value - The HashProviders instance to use\n\t */\n\tpublic set providers(value: HashProviders) {\n\t\tthis._providers = value;\n\t}\n\n\t/**\n\t * Gets the names of all registered hash algorithm providers.\n\t * @returns An array of provider names (e.g., ['SHA-256', 'SHA-384', 'SHA-512'])\n\t */\n\tpublic get names(): Array<string> {\n\t\treturn this._providers.names;\n\t}\n\n\t/**\n\t * Gets the default hash algorithm used when none is specified.\n\t * @returns The current default algorithm (defaults to 'SHA-256')\n\t */\n\tpublic get defaultAlgorithm(): string {\n\t\treturn this._defaultAlgorithm;\n\t}\n\n\t/**\n\t * Sets the default hash algorithm to use when none is specified.\n\t * @param value - The default algorithm to use (e.g., 'SHA-256', 'SHA-512', 'djb2')\n\t * @example\n\t * ```ts\n\t * const hashery = new Hashery();\n\t * hashery.defaultAlgorithm = 'SHA-512';\n\t *\n\t * // Now toHash will use SHA-512 by default\n\t * const hash = await hashery.toHash({ data: 'example' });\n\t * ```\n\t */\n\tpublic set defaultAlgorithm(value: string) {\n\t\tthis._defaultAlgorithm = value;\n\t}\n\n\t/**\n\t * Gets the default synchronous hash algorithm used when none is specified.\n\t * @returns The current default synchronous algorithm (defaults to 'djb2')\n\t */\n\tpublic get defaultAlgorithmSync(): string {\n\t\treturn this._defaultAlgorithmSync;\n\t}\n\n\t/**\n\t * Sets the default synchronous hash algorithm to use when none is specified.\n\t * @param value - The default synchronous algorithm to use (e.g., 'djb2', 'fnv1', 'murmer', 'crc32')\n\t * @example\n\t * ```ts\n\t * const hashery = new Hashery();\n\t * hashery.defaultAlgorithmSync = 'fnv1';\n\t *\n\t * // Now synchronous operations will use fnv1 by default\n\t * ```\n\t */\n\tpublic set defaultAlgorithmSync(value: string) {\n\t\tthis._defaultAlgorithmSync = value;\n\t}\n\n\t/**\n\t * Gets the cache instance used to store computed hash values.\n\t * @returns The Cache instance\n\t * @example\n\t * ```ts\n\t * const hashery = new Hashery({ cache: { enabled: true } });\n\t *\n\t * // Access the cache\n\t * hashery.cache.enabled; // true\n\t * hashery.cache.size; // number of cached items\n\t * hashery.cache.clear(); // clear all cached items\n\t * ```\n\t */\n\tpublic get cache(): Cache {\n\t\treturn this._cache;\n\t}\n\n\t/**\n\t * Generates a cryptographic hash of the provided data using the Web Crypto API.\n\t * The data is first stringified using the configured stringify function, then hashed.\n\t *\n\t * If an invalid algorithm is provided, a 'warn' event is emitted and the method falls back\n\t * to the default algorithm. You can listen to these warnings:\n\t * ```ts\n\t * hashery.on('warn', (message) => console.log(message));\n\t * ```\n\t *\n\t * @param data - The data to hash (will be stringified before hashing)\n\t * @param options - Optional configuration object\n\t * @param options.algorithm - The hash algorithm to use (defaults to 'SHA-256')\n\t * @param options.maxLength - Optional maximum length for the hash output\n\t * @returns A Promise that resolves to the hexadecimal string representation of the hash\n\t *\n\t * @example\n\t * ```ts\n\t * const hashery = new Hashery();\n\t * const hash = await hashery.toHash({ name: 'John', age: 30 });\n\t * console.log(hash); // \"a1b2c3d4...\"\n\t *\n\t * // Using a different algorithm\n\t * const hash512 = await hashery.toHash({ name: 'John' }, { algorithm: 'SHA-512' });\n\t * ```\n\t */\n\tpublic async toHash(\n\t\tdata: unknown,\n\t\toptions?: HasheryToHashOptions,\n\t): Promise<string> {\n\t\t// Before hook - allows modification of input data and algorithm\n\t\tconst context = {\n\t\t\tdata,\n\t\t\talgorithm: options?.algorithm ?? this._defaultAlgorithm,\n\t\t\tmaxLength: options?.maxLength,\n\t\t};\n\t\tawait this.beforeHook(\"toHash\", context);\n\n\t\t// Stringify the data using the configured stringify function\n\t\tconst stringified = this._stringify(context.data);\n\n\t\t// Check cache first\n\t\tconst cacheKey = `${context.algorithm}:${stringified}`;\n\t\tif (this._cache.enabled) {\n\t\t\tconst cached = this._cache.get(cacheKey);\n\t\t\tif (cached !== undefined) {\n\t\t\t\t// Apply maxLength if specified\n\t\t\t\tif (options?.maxLength && cached.length > options.maxLength) {\n\t\t\t\t\treturn cached.substring(0, options.maxLength);\n\t\t\t\t}\n\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\n\t\t// Convert the string to a Uint8Array\n\t\tconst encoder = new TextEncoder();\n\t\tconst dataBuffer = encoder.encode(stringified);\n\n\t\t// Get the provider for the specified algorithm\n\t\tlet provider = this._providers.get(context.algorithm);\n\t\tif (!provider) {\n\t\t\t// Emit warning for invalid algorithm\n\t\t\tthis.emit(\n\t\t\t\t\"warn\",\n\t\t\t\t`Invalid algorithm '${context.algorithm}' not found. Falling back to default algorithm '${this._defaultAlgorithm}'.`,\n\t\t\t);\n\n\t\t\tprovider = new WebCrypto({\n\t\t\t\talgorithm: this._defaultAlgorithm as WebCryptoHashAlgorithm,\n\t\t\t});\n\t\t}\n\n\t\t// Use the provider to hash the data\n\t\tlet hash = await provider.toHash(dataBuffer);\n\n\t\t// Store the full hash in cache before truncation\n\t\tif (this._cache.enabled) {\n\t\t\tthis._cache.set(cacheKey, hash);\n\t\t}\n\n\t\t// if there is a max then change the hash\n\t\tif (options?.maxLength && hash.length > options?.maxLength) {\n\t\t\thash = hash.substring(0, options.maxLength);\n\t\t}\n\n\t\t// After hook - allows modification/logging of result\n\t\tconst result = { hash, data: context.data, algorithm: context.algorithm };\n\t\tawait this.afterHook(\"toHash\", result);\n\n\t\treturn result.hash;\n\t}\n\n\t/**\n\t * Generates a deterministic number within a specified range based on the hash of the provided data.\n\t * This method uses the toHash function to create a consistent hash, then maps it to a number\n\t * between min and max (inclusive).\n\t *\n\t * @param data - The data to hash (will be stringified before hashing)\n\t * @param options - Configuration options (optional, defaults to min: 0, max: 100)\n\t * @param options.min - The minimum value of the range (inclusive, defaults to 0)\n\t * @param options.max - The maximum value of the range (inclusive, defaults to 100)\n\t * @param options.algorithm - The hash algorithm to use (defaults to 'SHA-256')\n\t * @param options.hashLength - Number of characters from hash to use for conversion (defaults to 16)\n\t * @returns A Promise that resolves to a number between min and max (inclusive)\n\t *\n\t * @example\n\t * ```ts\n\t * const hashery = new Hashery();\n\t * const num = await hashery.toNumber({ user: 'john' }); // Uses default min: 0, max: 100\n\t * console.log(num); // Always returns the same number for the same input, e.g., 42\n\t *\n\t * // Using custom range\n\t * const num2 = await hashery.toNumber({ user: 'john' }, { min: 1, max: 100 });\n\t *\n\t * // Using a different algorithm\n\t * const num512 = await hashery.toNumber({ user: 'john' }, { min: 0, max: 255, algorithm: 'SHA-512' });\n\t * ```\n\t */\n\tpublic async toNumber(\n\t\tdata: unknown,\n\t\toptions: HasheryToNumberOptions = {},\n\t): Promise<number> {\n\t\tconst {\n\t\t\tmin = 0,\n\t\t\tmax = 100,\n\t\t\talgorithm = this._defaultAlgorithm,\n\t\t\thashLength = 16,\n\t\t} = options;\n\n\t\tif (min > max) {\n\t\t\tthrow new Error(\"min cannot be greater than max\");\n\t\t}\n\n\t\t// Get the hash as a hex string\n\t\t// Take the first hashLength characters of the hash to convert to a number\n\t\t// This provides good distribution while avoiding precision issues with JavaScript numbers\n\t\tconst hash = await this.toHash(data, { algorithm, maxLength: hashLength });\n\n\t\t// Convert hex to a number\n\t\tconst hashNumber = Number.parseInt(hash, 16);\n\n\t\t// Map the hash number to the desired range\n\t\tconst range = max - min + 1;\n\t\tconst mapped = min + (hashNumber % range);\n\n\t\treturn mapped;\n\t}\n\n\t/**\n\t * Generates a hash of the provided data synchronously using a non-cryptographic hash algorithm.\n\t * The data is first stringified using the configured stringify function, then hashed.\n\t *\n\t * Note: This method only works with synchronous hash providers (djb2, fnv1, murmer, crc32).\n\t * WebCrypto algorithms (SHA-256, SHA-384, SHA-512) are not supported and will throw an error.\n\t *\n\t * If an invalid algorithm is provided, a 'warn' event is emitted and the method falls back\n\t * to the default synchronous algorithm. You can listen to these warnings:\n\t * ```ts\n\t * hashery.on('warn', (message) => console.log(message));\n\t * ```\n\t *\n\t * @param data - The data to hash (will be stringified before hashing)\n\t * @param options - Optional configuration object\n\t * @param options.algorithm - The hash algorithm to use (defaults to 'djb2')\n\t * @param options.maxLength - Optional maximum length for the hash output\n\t * @returns The hexadecimal string representation of the hash\n\t *\n\t * @throws {Error} If the specified algorithm does not support synchronous hashing\n\t * @throws {Error} If the default algorithm is not found\n\t *\n\t * @example\n\t * ```ts\n\t * const hashery = new Hashery();\n\t * const hash = hashery.toHashSync({ name: 'John', age: 30 });\n\t * console.log(hash); // \"7c9df5ea...\" (djb2 hash)\n\t *\n\t * // Using a different algorithm\n\t * const hashFnv1 = hashery.toHashSync({ name: 'John' }, { algorithm: 'fnv1' });\n\t * ```\n\t */\n\tpublic toHashSync(data: unknown, options?: HasheryToHashSyncOptions): string {\n\t\t// Before hook - allows modification of input data and algorithm (fires asynchronously)\n\t\tconst context = {\n\t\t\tdata,\n\t\t\talgorithm: options?.algorithm ?? this._defaultAlgorithmSync,\n\t\t\tmaxLength: options?.maxLength,\n\t\t};\n\t\tthis.beforeHook(\"toHashSync\", context);\n\n\t\t// Get algorithm from context (may have been modified by hook)\n\t\tconst algorithm = context.algorithm;\n\n\t\t// Stringify the data using the configured stringify function\n\t\tconst stringified = this._stringify(context.data);\n\n\t\t// Check cache first\n\t\tconst cacheKey = `${algorithm}:${stringified}`;\n\t\tif (this._cache.enabled) {\n\t\t\tconst cached = this._cache.get(cacheKey);\n\t\t\tif (cached !== undefined) {\n\t\t\t\t// Apply maxLength if specified\n\t\t\t\tif (options?.maxLength && cached.length > options.maxLength) {\n\t\t\t\t\treturn cached.substring(0, options.maxLength);\n\t\t\t\t}\n\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\n\t\t// Convert the string to a Uint8Array\n\t\tconst encoder = new TextEncoder();\n\t\tconst dataBuffer = encoder.encode(stringified);\n\n\t\t// Get the provider for the specified algorithm\n\t\tlet provider = this._providers.get(algorithm);\n\t\tif (!provider) {\n\t\t\t// Emit warning for invalid algorithm\n\t\t\tthis.emit(\n\t\t\t\t\"warn\",\n\t\t\t\t`Invalid algorithm '${algorithm}' not found. Falling back to default algorithm '${this._defaultAlgorithmSync}'.`,\n\t\t\t);\n\n\t\t\t// Fallback to default sync algorithm\n\t\t\tprovider = this._providers.get(this._defaultAlgorithmSync);\n\n\t\t\t// If default algorithm is also not found, throw error\n\t\t\tif (!provider) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Hash provider '${this._defaultAlgorithmSync}' (default) not found`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Check if provider supports synchronous hashing\n\t\tif (!provider.toHashSync) {\n\t\t\tthrow new Error(\n\t\t\t\t`Hash provider '${algorithm}' does not support synchronous hashing. Use toHash() instead or choose a different algorithm (djb2, fnv1, murmer, crc32).`,\n\t\t\t);\n\t\t}\n\n\t\t// Use the provider to hash the data synchronously\n\t\tlet hash = provider.toHashSync(dataBuffer);\n\n\t\t// Store the full hash in cache before truncation\n\t\tif (this._cache.enabled) {\n\t\t\tthis._cache.set(cacheKey, hash);\n\t\t}\n\n\t\t// if there is a max then change the hash\n\t\tif (options?.maxLength && hash.length > options?.maxLength) {\n\t\t\thash = hash.substring(0, options.maxLength);\n\t\t}\n\n\t\t// After hook - allows modification/logging of result (fires asynchronously)\n\t\tconst result = { hash, data: context.data, algorithm: context.algorithm };\n\t\tthis.afterHook(\"toHashSync\", result);\n\n\t\treturn result.hash;\n\t}\n\n\t/**\n\t * Generates a deterministic number within a specified range based on the hash of the provided data synchronously.\n\t * This method uses the toHashSync function to create a consistent hash, then maps it to a number\n\t * between min and max (inclusive).\n\t *\n\t * Note: This method only works with synchronous hash providers (djb2, fnv1, murmer, crc32).\n\t *\n\t * @param data - The data to hash (will be stringified before hashing)\n\t * @param options - Configuration options (optional, defaults to min: 0, max: 100)\n\t * @param options.min - The minimum value of the range (inclusive, defaults to 0)\n\t * @param options.max - The maximum value of the range (inclusive, defaults to 100)\n\t * @param options.algorithm - The hash algorithm to use (defaults to 'djb2')\n\t * @param options.hashLength - Number of characters from hash to use for conversion (defaults to 16)\n\t * @returns A number between min and max (inclusive)\n\t *\n\t * @throws {Error} If the specified algorithm does not support synchronous hashing\n\t * @throws {Error} If min is greater than max\n\t *\n\t * @example\n\t * ```ts\n\t * const hashery = new Hashery();\n\t * const num = hashery.toNumberSync({ user: 'john' }); // Uses default min: 0, max: 100\n\t * console.log(num); // Always returns the same number for the same input, e.g., 42\n\t *\n\t * // Using custom range\n\t * const num2 = hashery.toNumberSync({ user: 'john' }, { min: 1, max: 100 });\n\t *\n\t * // Using a different algorithm\n\t * const numFnv1 = hashery.toNumberSync({ user: 'john' }, { min: 0, max: 255, algorithm: 'fnv1' });\n\t * ```\n\t */\n\tpublic toNumberSync(\n\t\tdata: unknown,\n\t\toptions: HasheryToNumberSyncOptions = {},\n\t): number {\n\t\tconst {\n\t\t\tmin = 0,\n\t\t\tmax = 100,\n\t\t\talgorithm = this._defaultAlgorithmSync,\n\t\t\thashLength = 16,\n\t\t} = options;\n\n\t\tif (min > max) {\n\t\t\tthrow new Error(\"min cannot be greater than max\");\n\t\t}\n\n\t\t// Get the hash as a hex string\n\t\t// Take the first hashLength characters of the hash to convert to a number\n\t\t// This provides good distribution while avoiding precision issues with JavaScript numbers\n\t\tconst hash = this.toHashSync(data, { algorithm, maxLength: hashLength });\n\n\t\t// Convert hex to a number\n\t\tconst hashNumber = Number.parseInt(hash, 16);\n\n\t\t// Map the hash number to the desired range\n\t\tconst range = max - min + 1;\n\t\tconst mapped = min + (hashNumber % range);\n\n\t\treturn mapped;\n\t}\n\n\tpublic loadProviders(\n\t\tproviders?: Array<HashProvider>,\n\t\toptions: HasheryLoadProviderOptions = { includeBase: true },\n\t): void {\n\t\tif (providers) {\n\t\t\tfor (const provider of providers) {\n\t\t\t\tthis._providers.add(provider);\n\t\t\t}\n\t\t}\n\n\t\t// load all the providers\n\t\tif (options.includeBase) {\n\t\t\tthis.providers.add(new WebCrypto({ algorithm: \"SHA-256\" }));\n\t\t\tthis.providers.add(new WebCrypto({ algorithm: \"SHA-384\" }));\n\t\t\tthis.providers.add(new WebCrypto({ algorithm: \"SHA-512\" }));\n\t\t\tthis.providers.add(new CRC());\n\t\t\tthis.providers.add(new DJB2());\n\t\t\tthis.providers.add(new FNV1());\n\t\t\tthis.providers.add(new Murmer());\n\t\t}\n\t}\n}\n\nexport type { CacheOptions } from \"./cache.js\";\nexport { Cache } from \"./cache.js\";\nexport type { WebCryptoHashAlgorithm, HasheryOptions, ParseFn, StringifyFn };\n"],"mappings":"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","names":["Eventified","options","__publicField","logger","value","eventName","listener","onceListener","arguments_","listeners","event","index","result","error","n","data","message","Hookified","eventValue","warningMessage","handler","eventHandlers","hookEntry","hooks","hook","Cache","options","__publicField","value","key","oldestKey","CRC","data","bytes","view","CRC32_POLYNOMIAL","crc","i","j","WebCrypto","options","__publicField","data","hashBuffer","byte","DJB2","data","bytes","view","hash","i","FNV1","data","bytes","view","FNV_OFFSET_BASIS","FNV_PRIME","hash","i","Murmer","seed","__publicField","data","bytes","view","c1","c2","length","nblocks","h1","i","index","k1","tail","a","b","ah","al","bh","bl","x","HashProviders","options","__publicField","providers","provider","name","getFuzzy","result","Hashery","Hookified","options","__publicField","HashProviders","Cache","value","data","context","stringified","cacheKey","cached","dataBuffer","provider","WebCrypto","hash","result","min","max","algorithm","hashLength","hashNumber","range","providers","CRC","DJB2","FNV1","Murmer"]}