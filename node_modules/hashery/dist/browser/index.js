var A=Object.defineProperty;var S=(l,e,t)=>e in l?A(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var h=(l,e,t)=>S(l,typeof e!="symbol"?e+"":e,t);import{Hookified as w}from"hookified";var d=class{constructor(e){h(this,"_enabled",!0);h(this,"_maxSize",4e3);h(this,"_store",new Map);h(this,"_keys",[]);e?.enabled!==void 0&&(this._enabled=e.enabled),e?.maxSize!==void 0&&(this._maxSize=e.maxSize)}get enabled(){return this._enabled}set enabled(e){this._enabled=e}get maxSize(){return this._maxSize}set maxSize(e){this._maxSize=e}get store(){return this._store}get size(){return this._store.size}get(e){return this._store.get(e)}set(e,t){if(this._enabled){if(this._store.has(e)){this._store.set(e,t);return}if(this._store.size>=this._maxSize){let i=this._keys.shift();i&&this._store.delete(i)}this._keys.push(e),this._store.set(e,t)}}has(e){return this._store.has(e)}clear(){this._store.clear(),this._keys=[]}};var y=class{get name(){return"crc32"}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let a=e;t=new Uint8Array(a.buffer,a.byteOffset,a.byteLength)}let i=3988292384,r=4294967295;for(let a=0;a<t.length;a++){r=r^t[a];for(let s=0;s<8;s++)r=r>>>1^i&-(r&1)}return r=(r^4294967295)>>>0,r.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var p=class{constructor(e){h(this,"_algorithm","SHA-256");e?.algorithm&&(this._algorithm=e?.algorithm)}get name(){return this._algorithm}async toHash(e){let t=await crypto.subtle.digest(this._algorithm,e);return Array.from(new Uint8Array(t)).map(n=>n.toString(16).padStart(2,"0")).join("")}};var b=class{get name(){return"djb2"}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let n=e;t=new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}let i=5381;for(let n=0;n<t.length;n++)i=(i<<5)+i+t[n],i=i>>>0;return i.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var _=class{get name(){return"fnv1"}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let s=e;t=new Uint8Array(s.buffer,s.byteOffset,s.byteLength)}let i=2166136261,r=16777619,n=i;for(let s=0;s<t.length;s++)n=n*r,n=n^t[s],n=n>>>0;return n.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}};var v=class{constructor(e=0){h(this,"_seed");this._seed=e>>>0}get name(){return"murmer"}get seed(){return this._seed}toHashSync(e){let t;if(e instanceof Uint8Array)t=e;else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof DataView)t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);else{let c=e;t=new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}let i=3432918353,r=461845907,n=t.length,a=Math.floor(n/4),s=this._seed;for(let c=0;c<a;c++){let u=c*4,g=t[u]&255|(t[u+1]&255)<<8|(t[u+2]&255)<<16|(t[u+3]&255)<<24;g=this._imul(g,i),g=this._rotl32(g,15),g=this._imul(g,r),s^=g,s=this._rotl32(s,13),s=this._imul(s,5)+3864292196}let m=a*4,o=0;switch(n&3){case 3:o^=(t[m+2]&255)<<16;case 2:o^=(t[m+1]&255)<<8;case 1:o^=t[m]&255,o=this._imul(o,i),o=this._rotl32(o,15),o=this._imul(o,r),s^=o}return s^=n,s^=s>>>16,s=this._imul(s,2246822507),s^=s>>>13,s=this._imul(s,3266489909),s^=s>>>16,s=s>>>0,s.toString(16).padStart(8,"0")}async toHash(e){return this.toHashSync(e)}_imul(e,t){if(Math.imul)return Math.imul(e,t);let i=e>>>16&65535;let r=e&65535;let n=t>>>16&65535;let a=t&65535;return r*a+(i*a+r*n<<16>>>0)|0}_rotl32(e,t){return e<<t|e>>>32-t}};var H=class{constructor(e){h(this,"_providers",new Map);h(this,"_getFuzzy",!0);e?.providers&&this.loadProviders(e?.providers),e?.getFuzzy!==void 0&&(this._getFuzzy=!!e?.getFuzzy)}loadProviders(e){for(let t of e)this._providers.set(t.name,t)}get providers(){return this._providers}set providers(e){this._providers=e}get names(){return Array.from(this._providers.keys())}get(e,t){let i=t?.fuzzy??this._getFuzzy;e=e.trim();let r=this._providers.get(e);return r===void 0&&i===!0&&(e=e.toLowerCase(),r=this._providers.get(e)),r===void 0&&i===!0&&(e=e.replaceAll("-",""),r=this._providers.get(e)),r}add(e){this._providers.set(e.name,e)}remove(e){return this._providers.delete(e)}};var x=class extends w{constructor(t){super(t);h(this,"_parse",JSON.parse);h(this,"_stringify",JSON.stringify);h(this,"_providers",new H);h(this,"_defaultAlgorithm","SHA-256");h(this,"_defaultAlgorithmSync","djb2");h(this,"_cache");t?.parse&&(this._parse=t.parse),t?.stringify&&(this._stringify=t.stringify),t?.defaultAlgorithm&&(this._defaultAlgorithm=t.defaultAlgorithm),t?.defaultAlgorithmSync&&(this._defaultAlgorithmSync=t.defaultAlgorithmSync),this._cache=new d(t?.cache),this.loadProviders(t?.providers,{includeBase:t?.includeBase??!0})}get parse(){return this._parse}set parse(t){this._parse=t}get stringify(){return this._stringify}set stringify(t){this._stringify=t}get providers(){return this._providers}set providers(t){this._providers=t}get names(){return this._providers.names}get defaultAlgorithm(){return this._defaultAlgorithm}set defaultAlgorithm(t){this._defaultAlgorithm=t}get defaultAlgorithmSync(){return this._defaultAlgorithmSync}set defaultAlgorithmSync(t){this._defaultAlgorithmSync=t}get cache(){return this._cache}async toHash(t,i){let r={data:t,algorithm:i?.algorithm??this._defaultAlgorithm,maxLength:i?.maxLength};await this.beforeHook("toHash",r);let n=this._stringify(r.data),a=`${r.algorithm}:${n}`;if(this._cache.enabled){let u=this._cache.get(a);if(u!==void 0)return i?.maxLength&&u.length>i.maxLength?u.substring(0,i.maxLength):u}let m=new TextEncoder().encode(n),o=this._providers.get(r.algorithm);o||(this.emit("warn",`Invalid algorithm '${r.algorithm}' not found. Falling back to default algorithm '${this._defaultAlgorithm}'.`),o=new p({algorithm:this._defaultAlgorithm}));let f=await o.toHash(m);this._cache.enabled&&this._cache.set(a,f),i?.maxLength&&f.length>i?.maxLength&&(f=f.substring(0,i.maxLength));let c={hash:f,data:r.data,algorithm:r.algorithm};return await this.afterHook("toHash",c),c.hash}async toNumber(t,i={}){let{min:r=0,max:n=100,algorithm:a=this._defaultAlgorithm,hashLength:s=16}=i;if(r>n)throw new Error("min cannot be greater than max");let m=await this.toHash(t,{algorithm:a,maxLength:s}),o=Number.parseInt(m,16),f=n-r+1;return r+o%f}toHashSync(t,i){let r={data:t,algorithm:i?.algorithm??this._defaultAlgorithmSync,maxLength:i?.maxLength};this.beforeHook("toHashSync",r);let n=r.algorithm,a=this._stringify(r.data),s=`${n}:${a}`;if(this._cache.enabled){let g=this._cache.get(s);if(g!==void 0)return i?.maxLength&&g.length>i.maxLength?g.substring(0,i.maxLength):g}let o=new TextEncoder().encode(a),f=this._providers.get(n);if(!f&&(this.emit("warn",`Invalid algorithm '${n}' not found. Falling back to default algorithm '${this._defaultAlgorithmSync}'.`),f=this._providers.get(this._defaultAlgorithmSync),!f))throw new Error(`Hash provider '${this._defaultAlgorithmSync}' (default) not found`);if(!f.toHashSync)throw new Error(`Hash provider '${n}' does not support synchronous hashing. Use toHash() instead or choose a different algorithm (djb2, fnv1, murmer, crc32).`);let c=f.toHashSync(o);this._cache.enabled&&this._cache.set(s,c),i?.maxLength&&c.length>i?.maxLength&&(c=c.substring(0,i.maxLength));let u={hash:c,data:r.data,algorithm:r.algorithm};return this.afterHook("toHashSync",u),u.hash}toNumberSync(t,i={}){let{min:r=0,max:n=100,algorithm:a=this._defaultAlgorithmSync,hashLength:s=16}=i;if(r>n)throw new Error("min cannot be greater than max");let m=this.toHashSync(t,{algorithm:a,maxLength:s}),o=Number.parseInt(m,16),f=n-r+1;return r+o%f}loadProviders(t,i={includeBase:!0}){if(t)for(let r of t)this._providers.add(r);i.includeBase&&(this.providers.add(new p({algorithm:"SHA-256"})),this.providers.add(new p({algorithm:"SHA-384"})),this.providers.add(new p({algorithm:"SHA-512"})),this.providers.add(new y),this.providers.add(new b),this.providers.add(new _),this.providers.add(new v))}};export{d as Cache,x as Hashery};
/* v8 ignore next -- @preserve */
//# sourceMappingURL=index.js.map